#include "ap_server.h"
#include "pico/cyw43_arch.h"
#include "pico/stdlib.h"
#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/udp.h"
#include "lwip/err.h"
#include "lwip/ip4_addr.h"
#include "dhcpserver.h"
#include "config_parser.h"
#include "littlefs_hal.h"
#include "lfs.h"
#include "hardware/watchdog.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#ifndef TCP_WRITE_FLAG_COPY
#define TCP_WRITE_FLAG_COPY 0x01
#endif

#define AP_PASSWORD "rockband"
#define AP_IP_OCTET 4

/* ---------------- Globals ---------------- */

static dhcp_server_t dhcp_server;
static struct udp_pcb *dns_pcb;

static volatile bool save_pending = false;
static volatile bool reboot_required = false;

static char pending_ssid[64];
static char pending_pass[64];

/* ---------------- HTML ---------------- */

static const char *html_form =
    "<!DOCTYPE html><html><head>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>Setup</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:20px;'>"
    "<h1>StageKit Setup</h1>"
    "<form action='/save' method='get'>"
    "SSID:<br><input name='s'><br><br>"
    "Password:<br><input name='p' type='password'><br><br>"
    "<input type='submit' value='Save & Connect'>"
    "</form></body></html>";

static const char *html_done =
    "<html><body style='font-family:sans-serif;text-align:center;padding:40px;'>"
    "<h1>Saved</h1><p>Rebooting...</p></body></html>";

/* ---------------- LittleFS SAVE ---------------- */

void save_wifi_config(const char *ssid, const char *password) {
    lfs_t *lfs = littlefs_get();
    lfs_file_t file;

    int err = lfs_file_open(lfs, &file, CONFIG_FILE_PATH,
                            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC);
    if (err < 0) {
        printf("AP: Failed to open %s for writing (err=%d)\n",
               CONFIG_FILE_PATH, err);
        return;
    }

    char file_content[256];
    snprintf(file_content, sizeof(file_content),
        "# Auto-generated by AP Setup\n"
        "CIRCUITPY_WIFI_SSID = \"%s\"\n"
        "CIRCUITPY_WIFI_PASSWORD = \"%s\"\n",
        ssid, password);

    lfs_ssize_t written = lfs_file_write(lfs, &file,
                                         file_content,
                                         strlen(file_content));
    lfs_file_close(lfs, &file);

    if (written > 0) {
        printf("AP: Config saved to %s (%d bytes)\n",
               CONFIG_FILE_PATH, (int)written);
    } else {
        printf("AP: Failed to write config (err=%d)\n", (int)written);
    }
}

/* ---------------- DNS WILDCARD ---------------- */

static void dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p,
                     const ip_addr_t *addr, u16_t port) {
    if (!p || p->len < 12) {
        if (p) pbuf_free(p);
        return;
    }

    struct pbuf *resp = pbuf_alloc(PBUF_TRANSPORT, p->len + 16, PBUF_RAM);
    if (!resp) {
        pbuf_free(p);
        return;
    }

    memcpy(resp->payload, p->payload, p->len);
    uint8_t *r = (uint8_t *)resp->payload;

    r[2] |= 0x80;  // response
    r[3] |= 0x80;
    r[7] = 1;      // one answer

    uint16_t idx = p->len;
    // DNS Resource Record
    r[idx++] = 0xC0; r[idx++] = 0x0C; // Pointer to name
    r[idx++] = 0x00; r[idx++] = 0x01; // Type A
    r[idx++] = 0x00; r[idx++] = 0x01; // Class IN
    r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x3C; // TTL
    r[idx++] = 0x00; r[idx++] = 0x04; // Data length
    r[idx++] = 192; r[idx++] = 168; r[idx++] = AP_IP_OCTET; r[idx++] = 1; // IP

    resp->len = resp->tot_len = idx;
    udp_sendto(pcb, resp, addr, port);

    pbuf_free(resp);
    pbuf_free(p);
}

static void dns_start(void) {
    dns_pcb = udp_new();
    udp_bind(dns_pcb, IP_ADDR_ANY, 53);
    udp_recv(dns_pcb, dns_recv, NULL);
}

/* ---------------- URL / Query ---------------- */

static void url_decode_n(char *dst, size_t dst_len, const char *src) {
    size_t i = 0;
    while (*src && i + 1 < dst_len) {
        if (*src == '%' && src[1] && src[2]) {
            char a = src[1];
            char b = src[2];
            a = (a >= 'a') ? a - 'a' + 'A' : a;
            b = (b >= 'a') ? b - 'a' + 'A' : b;
            a = (a >= 'A') ? a - 'A' + 10 : a - '0';
            b = (b >= 'A') ? b - 'A' + 10 : b - '0';
            dst[i++] = (a << 4) | b;
            src += 3;
        } else if (*src == '+') {
            dst[i++] = ' ';
            src++;
        } else {
            dst[i++] = *src++;
        }
    }
    dst[i] = 0;
}

static void parse_query(const char *q) {
    const char *s = strstr(q, "s=");
    const char *p = strstr(q, "p=");
    if (!s || !p) return;

    char tmp[128];

    s += 2;
    size_t sl = strcspn(s, "& ");
    strncpy(tmp, s, sl);
    tmp[sl] = 0;
    url_decode_n(pending_ssid, sizeof(pending_ssid), tmp);

    p += 2;
    size_t pl = strcspn(p, "& ");
    strncpy(tmp, p, pl);
    tmp[pl] = 0;
    url_decode_n(pending_pass, sizeof(pending_pass), tmp);

    save_pending = true;
}

/* ---------------- HTTP / TCP ---------------- */

static bool is_captive_probe(const char *req) {
    return strstr(req, "generate_204") ||
           strstr(req, "connectivitycheck") ||
           strstr(req, "hotspot-detect.html");
}

static err_t http_sent_cb(void *arg, struct tcp_pcb *pcb, u16_t len) {
    tcp_close(pcb);
    return ERR_OK;
}

static void send_http_response(struct tcp_pcb *pcb, const char *body, const char *status, const char *location) {
    char buf[1024]; // Combine everything here
    size_t len = body ? strlen(body) : 0;
    int written = 0;

    if (location) {
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.0 %s\r\n"
            "Location: %s\r\n"
            "Connection: close\r\n\r\n",
            status, location);
    } else {
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.0 %s\r\n"
            "Content-Type: text/html\r\n"
            "Content-Length: %u\r\n"
            "Connection: close\r\n\r\n"
            "%s", // Append body directly
            status, (unsigned)len, body ? body : "");
    }

    // Single atomic write call
    if (written > 0 && written < (int)sizeof(buf)) {
        tcp_write(pcb, buf, written, TCP_WRITE_FLAG_COPY);
    }

    tcp_output(pcb);
    tcp_sent(pcb, http_sent_cb); // Close after ack
}

static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) {
    if (!p) {
        tcp_close(pcb);
        return ERR_OK;
    }

    tcp_recved(pcb, p->tot_len);

    char buf[1024]; // Larger buffer
    u16_t len = p->tot_len > sizeof(buf) - 1 ? sizeof(buf) - 1 : p->tot_len;
    pbuf_copy_partial(p, buf, len, 0);
    buf[len] = 0;

    char *line = strstr(buf, "\r\n");
    if (line) *line = 0;

    if (strncmp(buf, "GET /save?", 10) == 0) {
        parse_query(buf + 10);
        send_http_response(pcb, NULL, "302 Found", "/done");
    } else if (strncmp(buf, "GET /done", 9) == 0) {
        send_http_response(pcb, html_done, "200 OK", NULL);
    } else if (is_captive_probe(buf)) {
        send_http_response(pcb, html_form, "200 OK", NULL);
    } else {
        send_http_response(pcb, html_form, "200 OK", NULL);
    }

    pbuf_free(p);
    return ERR_OK;
}

static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err) {
    tcp_recv(pcb, http_recv);
    return ERR_OK;
}

/* ---------------- MAIN AP MODE ---------------- */

void run_ap_setup_mode(void) {
    uint8_t mac[6];
    char ssid[32];

    if (cyw43_wifi_get_mac(&cyw43_state, CYW43_ITF_AP, mac) == 0) {
        snprintf(ssid, sizeof(ssid), "StageKit-%02X%02X%02X",
                 mac[3], mac[4], mac[5]);
    } else {
        strcpy(ssid, "StageKit-Setup");
    }
    
    printf("AP: Starting Access Point '%s'...\n", ssid);

    cyw43_arch_enable_ap_mode(ssid, AP_PASSWORD, CYW43_AUTH_WPA2_AES_PSK);

    // Disable power save mode to ensure web server responsiveness
    cyw43_wifi_pm(&cyw43_state, cyw43_pm_value(CYW43_NO_POWERSAVE_MODE, 20, 1, 1, 1));

    ip4_addr_t ip, mask, gw;
    IP4_ADDR(&ip, 192, 168, AP_IP_OCTET, 1);
    IP4_ADDR(&mask, 255, 255, 255, 0);
    IP4_ADDR(&gw, 192, 168, AP_IP_OCTET, 1); // AP is its own gateway

    struct netif *n = &cyw43_state.netif[CYW43_ITF_AP];

    cyw43_arch_lwip_begin()
    
    netif_set_addr(n, &ip, &mask, &gw);
    netif_set_up(n);
    netif_set_default(n);
        
    dhcp_server_init(&dhcp_server, &ip, &mask);
    dns_start();

    struct tcp_pcb *pcb = tcp_new();
    
    // FIX 2: Bind to IP_ADDR_ANY instead of specific IP
    err_t err = tcp_bind(pcb, IP_ADDR_ANY, 80); 
    
    if (err != ERR_OK) {
        printf("AP: Failed to bind TCP (err=%d)\n", err);
    } else {
        pcb = tcp_listen(pcb);
        tcp_accept(pcb, http_accept);
    }
    
    cyw43_arch_lwip_end();

    while (true) {
        if (save_pending) {
            save_pending = false;
            save_wifi_config(pending_ssid, pending_pass);
            reboot_required = true;
        }

        if (reboot_required) {
            // FIX 3: Wait for HTTP response to flush before rebooting
            printf("AP: Rebooting in 1s...\n");
            sleep_ms(1000); 
            watchdog_enable(100, 1);
            while (1);
        }

        watchdog_update();
        sleep_ms(200);
    }
}


