#include "ap_server.h"
#include "pico/cyw43_arch.h"
#include "pico/stdlib.h"
#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/udp.h"
#include "lwip/err.h"
#include "lwip/ip4_addr.h"
#include "dhcpserver.h"
#include "config_parser.h"
#include "littlefs_hal.h"
#include "lfs.h"
#include "hardware/watchdog.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#ifndef TCP_WRITE_FLAG_COPY
#define TCP_WRITE_FLAG_COPY 0x01
#endif

#define AP_PASSWORD "rockband"
#define AP_IP_OCTET 4

/* ---------------- Globals ---------------- */

static dhcp_server_t dhcp_server;
static struct udp_pcb *dns_pcb;

static volatile bool save_pending = false;
static volatile bool reboot_required = false;

static char pending_ssid[64];
static char pending_pass[64];

/* ---------------- HTML ---------------- */

static const char *html_form =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>StageKit Setup</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:20px;'>"
    "<h1>StageKit Setup</h1>"
    "<form action='/save' method='get'>"
    "SSID:<br><input name='s' maxlength='32'><br><br>"
    "Password:<br><input name='p' type='password' maxlength='63'><br><br>"
    "<input type='submit' value='Save &amp; Connect'>"
    "</form></body></html>";

static const char *html_done =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>Saved</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:40px;'>"
    "<h1>Saved!</h1><p>Rebooting to connect...</p></body></html>";

/* ---------------- LittleFS SAVE ---------------- */

void save_wifi_config(const char *ssid, const char *password) {
    lfs_t *lfs = littlefs_get();
    lfs_file_t file;

    int err = lfs_file_open(lfs, &file, CONFIG_FILE_PATH,
                            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC);
    if (err < 0) {
        printf("AP: Failed to open %s for writing (err=%d)\n",
               CONFIG_FILE_PATH, err);
        return;
    }

    char file_content[256];
    snprintf(file_content, sizeof(file_content),
        "# Auto-generated by AP Setup\n"
        "CIRCUITPY_WIFI_SSID = \"%s\"\n"
        "CIRCUITPY_WIFI_PASSWORD = \"%s\"\n",
        ssid, password);

    lfs_ssize_t written = lfs_file_write(lfs, &file,
                                         file_content,
                                         strlen(file_content));
    lfs_file_close(lfs, &file);

    if (written > 0) {
        printf("AP: Config saved to %s (%d bytes)\n",
               CONFIG_FILE_PATH, (int)written);
    } else {
        printf("AP: Failed to write config (err=%d)\n", (int)written);
    }
}

/* ---------------- DNS WILDCARD ---------------- */

static void dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p,
                     const ip_addr_t *addr, u16_t port) {
    if (!p || p->len < 12) {
        if (p) pbuf_free(p);
        return;
    }

    struct pbuf *resp = pbuf_alloc(PBUF_TRANSPORT, p->len + 16, PBUF_RAM);
    if (!resp) {
        pbuf_free(p);
        return;
    }

    memcpy(resp->payload, p->payload, p->len);
    uint8_t *r = (uint8_t *)resp->payload;

    r[2] |= 0x80;  // response
    r[3] |= 0x80;
    r[7] = 1;      // one answer

    uint16_t idx = p->len;
    // DNS Resource Record
    r[idx++] = 0xC0; r[idx++] = 0x0C; // Pointer to name
    r[idx++] = 0x00; r[idx++] = 0x01; // Type A
    r[idx++] = 0x00; r[idx++] = 0x01; // Class IN
    r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x3C; // TTL
    r[idx++] = 0x00; r[idx++] = 0x04; // Data length
    r[idx++] = 192; r[idx++] = 168; r[idx++] = AP_IP_OCTET; r[idx++] = 1; // IP

    resp->len = resp->tot_len = idx;
    udp_sendto(pcb, resp, addr, port);

    pbuf_free(resp);
    pbuf_free(p);
}

static bool dns_start(void) {
    dns_pcb = udp_new();
    if (!dns_pcb) {
        printf("AP: Failed to create DNS UDP PCB\n");
        return false;
    }

    err_t err = udp_bind(dns_pcb, IP_ADDR_ANY, 53);
    if (err != ERR_OK) {
        printf("AP: Failed to bind DNS port 53 (err=%d)\n", err);
        udp_remove(dns_pcb);
        dns_pcb = NULL;
        return false;
    }

    udp_recv(dns_pcb, dns_recv, NULL);
    printf("AP: DNS server started on port 53\n");
    return true;
}

/* ---------------- URL / Query ---------------- */

static void url_decode_n(char *dst, size_t dst_len, const char *src) {
    size_t i = 0;
    while (*src && i + 1 < dst_len) {
        if (*src == '%' && src[1] && src[2]) {
            char a = src[1];
            char b = src[2];
            a = (a >= 'a') ? a - 'a' + 'A' : a;
            b = (b >= 'a') ? b - 'a' + 'A' : b;
            a = (a >= 'A') ? a - 'A' + 10 : a - '0';
            b = (b >= 'A') ? b - 'A' + 10 : b - '0';
            dst[i++] = (a << 4) | b;
            src += 3;
        } else if (*src == '+') {
            dst[i++] = ' ';
            src++;
        } else {
            dst[i++] = *src++;
        }
    }
    dst[i] = 0;
}

static void parse_query(const char *q) {
    const char *s = strstr(q, "s=");
    const char *p = strstr(q, "p=");
    if (!s || !p) return;

    char tmp[128];

    s += 2;
    size_t sl = strcspn(s, "& ");
    strncpy(tmp, s, sl);
    tmp[sl] = 0;
    url_decode_n(pending_ssid, sizeof(pending_ssid), tmp);

    p += 2;
    size_t pl = strcspn(p, "& ");
    strncpy(tmp, p, pl);
    tmp[pl] = 0;
    url_decode_n(pending_pass, sizeof(pending_pass), tmp);

    save_pending = true;
}

/* ---------------- HTTP / TCP ---------------- */

// Detect captive portal probe requests from various OS/browsers
static bool is_captive_probe(const char *req) {
    // Android/Chrome
    if (strstr(req, "generate_204")) return true;
    if (strstr(req, "connectivitycheck")) return true;

    // iOS/macOS
    if (strstr(req, "hotspot-detect")) return true;
    if (strstr(req, "captive.apple.com")) return true;

    // Windows
    if (strstr(req, "msftconnecttest")) return true;
    if (strstr(req, "msftncsi")) return true;
    if (strstr(req, "connecttest.txt")) return true;
    if (strstr(req, "ncsi.txt")) return true;

    // Firefox
    if (strstr(req, "detectportal")) return true;
    if (strstr(req, "success.txt")) return true;

    // Samsung
    if (strstr(req, "samsung")) return true;

    return false;
}

// Check if this is a favicon request (avoid wasting bandwidth)
static bool is_favicon_request(const char *req) {
    return strstr(req, "favicon.ico") != NULL;
}

// Send a minimal 204 No Content response (for favicon, etc.)
static bool send_http_204(struct tcp_pcb *pcb) {
    const char *response =
        "HTTP/1.1 204 No Content\r\n"
        "Connection: close\r\n\r\n";
    size_t len = strlen(response);

    err_t err = tcp_write(pcb, response, len, TCP_WRITE_FLAG_COPY);
    if (err != ERR_OK) {
        tcp_abort(pcb);
        return false;
    }
    tcp_output(pcb);
    tcp_sent(pcb, http_sent_cb);
    return true;
}

static err_t http_sent_cb(void *arg, struct tcp_pcb *pcb, u16_t len) {
    tcp_close(pcb);
    return ERR_OK;
}

static void http_err_cb(void *arg, err_t err) {
    // Connection error occurred (timeout, reset, etc.)
    // The PCB is already freed by lwIP when this is called
    printf("AP: TCP connection error (err=%d)\n", err);
}

// Returns true if response was sent successfully, false if connection was aborted
static bool send_http_response(struct tcp_pcb *pcb, const char *body, const char *status, const char *location) {
    char buf[1024];
    size_t len = body ? strlen(body) : 0;
    int written = 0;

    if (location) {
        // Redirect response
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.1 %s\r\n"
            "Location: %s\r\n"
            "Cache-Control: no-cache, no-store, must-revalidate\r\n"
            "Connection: close\r\n"
            "Content-Length: 0\r\n\r\n",
            status, location);
    } else {
        // Content response with proper headers for modern browsers
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.1 %s\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "Content-Length: %u\r\n"
            "Cache-Control: no-cache, no-store, must-revalidate\r\n"
            "Connection: close\r\n\r\n"
            "%s",
            status, (unsigned)len, body ? body : "");
    }

    if (written > 0 && written < (int)sizeof(buf)) {
        err_t err = tcp_write(pcb, buf, written, TCP_WRITE_FLAG_COPY);
        if (err != ERR_OK) {
            printf("AP: tcp_write failed (err=%d)\n", err);
            tcp_abort(pcb);
            return false;
        }

        err = tcp_output(pcb);
        if (err != ERR_OK) {
            printf("AP: tcp_output failed (err=%d)\n", err);
        }
    } else {
        printf("AP: Response too large or snprintf failed (written=%d)\n", written);
        tcp_abort(pcb);
        return false;
    }

    tcp_sent(pcb, http_sent_cb);
    return true;
}

static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) {
    // Check for errors or connection close
    if (err != ERR_OK) {
        printf("AP: http_recv called with error (err=%d)\n", err);
        if (p) pbuf_free(p);
        return err;
    }

    if (!p) {
        // Client closed connection
        tcp_close(pcb);
        return ERR_OK;
    }

    tcp_recved(pcb, p->tot_len);

    char buf[1024];
    u16_t len = p->tot_len > sizeof(buf) - 1 ? sizeof(buf) - 1 : p->tot_len;
    pbuf_copy_partial(p, buf, len, 0);
    buf[len] = 0;

    char *line = strstr(buf, "\r\n");
    if (line) *line = 0;

    printf("AP: HTTP request: %.60s%s\n", buf, strlen(buf) > 60 ? "..." : "");

    bool success;
    if (strncmp(buf, "GET /save?", 10) == 0) {
        // Form submission - save and redirect to done page
        parse_query(buf + 10);
        success = send_http_response(pcb, NULL, "302 Found", "/done");
    } else if (strncmp(buf, "GET /done", 9) == 0) {
        // Confirmation page after save
        success = send_http_response(pcb, html_done, "200 OK", NULL);
    } else if (is_favicon_request(buf)) {
        // Favicon - return 204 No Content to save bandwidth
        success = send_http_204(pcb);
    } else if (is_captive_probe(buf)) {
        // Captive portal probe - redirect to trigger portal popup
        // Using 302 redirect is more reliable than serving content directly
        success = send_http_response(pcb, NULL, "302 Found", "http://192.168.4.1/");
    } else if (strncmp(buf, "GET / ", 6) == 0 || strncmp(buf, "GET /index", 10) == 0) {
        // Main page request
        success = send_http_response(pcb, html_form, "200 OK", NULL);
    } else {
        // Any other request - serve the form (catch-all for captive portal)
        success = send_http_response(pcb, html_form, "200 OK", NULL);
    }

    pbuf_free(p);

    // If send_http_response aborted the connection, we must return ERR_ABRT
    // to tell lwIP the PCB is no longer valid
    return success ? ERR_OK : ERR_ABRT;
}

static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err) {
    if (err != ERR_OK || pcb == NULL) {
        printf("AP: http_accept error (err=%d, pcb=%p)\n", err, pcb);
        return ERR_VAL;
    }

    printf("AP: New HTTP connection from %s\n", ip4addr_ntoa(&pcb->remote_ip));

    // Set up callbacks for this connection
    tcp_recv(pcb, http_recv);
    tcp_err(pcb, http_err_cb);

    return ERR_OK;
}

/* ---------------- MAIN AP MODE ---------------- */

void run_ap_setup_mode(void) {
    uint8_t mac[6];
    char ssid[32];

    if (cyw43_wifi_get_mac(&cyw43_state, CYW43_ITF_AP, mac) == 0) {
        snprintf(ssid, sizeof(ssid), "StageKit-%02X%02X%02X",
                 mac[3], mac[4], mac[5]);
    } else {
        strcpy(ssid, "StageKit-Setup");
    }
    
    printf("AP: Starting Access Point '%s'...\n", ssid);

    cyw43_arch_enable_ap_mode(ssid, AP_PASSWORD, CYW43_AUTH_WPA2_AES_PSK);

    // CRITICAL: Give the CYW43 time to fully initialize the AP
    // Without this delay, TCP connections may fail even though WiFi associates
    printf("AP: Waiting for AP to initialize...\n");
    for (int i = 0; i < 20; i++) {
        watchdog_update();
        sleep_ms(100);
    }
    printf("AP: AP ready\n");

    // Disable power save mode to ensure web server responsiveness
    cyw43_wifi_pm(&cyw43_state, cyw43_pm_value(CYW43_NO_POWERSAVE_MODE, 20, 1, 1, 1));

    ip4_addr_t ip, mask, gw;
    IP4_ADDR(&ip, 192, 168, AP_IP_OCTET, 1);
    IP4_ADDR(&mask, 255, 255, 255, 0);
    IP4_ADDR(&gw, 192, 168, AP_IP_OCTET, 1); // AP is its own gateway

    struct netif *n = &cyw43_state.netif[CYW43_ITF_AP];

    cyw43_arch_lwip_begin();
    
    netif_set_addr(n, &ip, &mask, &gw);
    netif_set_up(n);
    netif_set_default(n);
        
    dhcp_server_init(&dhcp_server, &ip, &mask);

    if (!dns_start()) {
        printf("AP: WARNING - DNS server failed to start, captive portal may not work\n");
    }

    struct tcp_pcb *pcb = tcp_new();
    if (!pcb) {
        printf("AP: Failed to create TCP PCB\n");
        cyw43_arch_lwip_end();
        return;
    }

    err_t err = tcp_bind(pcb, IP_ADDR_ANY, 80);

    if (err != ERR_OK) {
        printf("AP: Failed to bind TCP port 80 (err=%d)\n", err);
        tcp_close(pcb);
    } else {
        struct tcp_pcb *listen_pcb = tcp_listen(pcb);
        if (!listen_pcb) {
            printf("AP: tcp_listen failed\n");
            tcp_close(pcb);
        } else {
            tcp_accept(listen_pcb, http_accept);
            printf("AP: HTTP server listening on port 80\n");
        }
    }
    
    cyw43_arch_lwip_end();

    while (true) {
        // CRITICAL: Poll the network stack to process TCP callbacks
        // Without this, TCP connections may not be handled reliably
        cyw43_arch_poll();

        if (save_pending) {
            save_pending = false;
            save_wifi_config(pending_ssid, pending_pass);
            reboot_required = true;
        }

        if (reboot_required) {
            // Allow time for HTTP response to be sent before rebooting
            printf("AP: Rebooting in 1s...\n");
            for (int i = 0; i < 50; i++) {
                cyw43_arch_poll();  // Keep polling during reboot delay
                sleep_ms(20);
            }
            watchdog_enable(100, 1);
            while (1);
        }

        watchdog_update();
        sleep_ms(10);  // Reduced from 200ms for more responsive TCP handling
    }
}



