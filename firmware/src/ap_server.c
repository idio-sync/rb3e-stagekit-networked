#include "ap_server.h"
#include "pico/cyw43_arch.h"
#include "pico/stdlib.h"
#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/udp.h"
#include "lwip/err.h"
#include "lwip/ip4_addr.h"
#include "lwip/netif.h"
#include "dhcpserver.h"
#include "config_parser.h"
#include "littlefs_hal.h"
#include "lfs.h"
#include "hardware/watchdog.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#ifndef TCP_WRITE_FLAG_COPY
#define TCP_WRITE_FLAG_COPY 0x01
#endif

#define AP_PASSWORD "rockband"
#define AP_IP_OCTET 4

/* ---------------- Globals ---------------- */

static dhcp_server_t dhcp_server;
static struct udp_pcb *dns_pcb;

static volatile bool reboot_required = false;

static char pending_ssid[64];
static char pending_pass[64];

/* ---------------- HTML ---------------- */

static const char *html_form =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>StageKit Setup</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:20px;'>"
    "<h1>StageKit Setup</h1>"
    "<form action='/save' method='get'>"
    "SSID:<br><input name='s' maxlength='32'><br><br>"
    "Password:<br><input name='p' type='password' maxlength='63'><br><br>"
    "<input type='submit' value='Save &amp; Connect'>"
    "</form></body></html>";

static const char *html_done =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>Saved</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:40px;'>"
    "<h1>Saved!</h1><p>Rebooting to connect...</p></body></html>";

static const char *html_error_validation =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>Error</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:40px;'>"
    "<h1>Invalid Input</h1>"
    "<p>SSID is required (1-32 chars).<br>"
    "Password must be empty or 8-63 chars.</p>"
    "<p><a href='/'>Try Again</a></p></body></html>";

static const char *html_error_save =
    "<!DOCTYPE html><html><head>"
    "<meta charset='utf-8'>"
    "<meta name='viewport' content='width=device-width, initial-scale=1'>"
    "<title>Error</title></head>"
    "<body style='font-family:sans-serif;text-align:center;padding:40px;'>"
    "<h1>Save Failed</h1>"
    "<p>Could not save settings to flash.</p>"
    "<p><a href='/'>Try Again</a></p></body></html>";

/* ---------------- LittleFS SAVE ---------------- */

// Escape quotes and backslashes for TOML string
static void escape_toml_string(char *dst, size_t dst_len, const char *src) {
    size_t i = 0;
    while (*src && i + 2 < dst_len) {  // +2 for potential escape + null
        if (*src == '"' || *src == '\\') {
            dst[i++] = '\\';
        }
        dst[i++] = *src++;
    }
    dst[i] = 0;
}

// Returns true on success, false on failure
bool save_wifi_config(const char *ssid, const char *password) {
    lfs_t *lfs = littlefs_get();
    lfs_file_t file;

    // Feed watchdog before flash operation
    watchdog_update();

    int err = lfs_file_open(lfs, &file, CONFIG_FILE_PATH,
                            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC);
    if (err < 0) {
        printf("AP: Failed to open %s for writing (err=%d)\n",
               CONFIG_FILE_PATH, err);
        return false;
    }

    // Escape quotes in SSID and password to prevent TOML corruption
    char escaped_ssid[128];
    char escaped_pass[128];
    escape_toml_string(escaped_ssid, sizeof(escaped_ssid), ssid);
    escape_toml_string(escaped_pass, sizeof(escaped_pass), password);

    char file_content[512];
    int content_len = snprintf(file_content, sizeof(file_content),
        "# Auto-generated by AP Setup\n"
        "CIRCUITPY_WIFI_SSID = \"%s\"\n"
        "CIRCUITPY_WIFI_PASSWORD = \"%s\"\n",
        escaped_ssid, escaped_pass);

    if (content_len < 0 || content_len >= (int)sizeof(file_content)) {
        printf("AP: Config content too large\n");
        lfs_file_close(lfs, &file);
        return false;
    }

    lfs_ssize_t written = lfs_file_write(lfs, &file, file_content, content_len);

    // Sync to ensure data is committed to flash before we reboot
    int sync_err = lfs_file_sync(lfs, &file);

    lfs_file_close(lfs, &file);

    // Feed watchdog after flash operation
    watchdog_update();

    if (written != content_len) {
        printf("AP: Failed to write config (written=%d, expected=%d)\n",
               (int)written, content_len);
        return false;
    }

    if (sync_err < 0) {
        printf("AP: Failed to sync config (err=%d)\n", sync_err);
        return false;
    }

    printf("AP: Config saved to %s (%d bytes)\n", CONFIG_FILE_PATH, (int)written);
    return true;
}

/* ---------------- DNS WILDCARD ---------------- */

// DNS query types
#define DNS_TYPE_A     1   // IPv4 address
#define DNS_TYPE_AAAA  28  // IPv6 address

// Extract the query type from a DNS request
// Returns the QTYPE, or 0 if parsing fails
static uint16_t dns_get_query_type(const uint8_t *data, uint16_t len) {
    if (len < 12) return 0;

    // Skip 12-byte header, parse through the question name
    uint16_t pos = 12;

    // Name is a sequence of length-prefixed labels, ending with 0
    while (pos < len) {
        uint8_t label_len = data[pos];
        if (label_len == 0) {
            pos++;  // Skip the null terminator
            break;
        }
        if (label_len > 63) {
            // Compression pointer or invalid - shouldn't happen in query
            return 0;
        }
        pos += label_len + 1;
    }

    // Now pos should point to QTYPE (2 bytes) followed by QCLASS (2 bytes)
    if (pos + 4 > len) return 0;

    uint16_t qtype = (data[pos] << 8) | data[pos + 1];
    return qtype;
}

static void dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p,
                     const ip_addr_t *addr, u16_t port) {
    if (!p || p->len < 12) {
        if (p) pbuf_free(p);
        return;
    }

    const uint8_t *query = (const uint8_t *)p->payload;
    uint16_t qtype = dns_get_query_type(query, p->len);

    // Only respond to A (IPv4) queries with an A record
    // For AAAA (IPv6) and other types, return empty answer
    bool has_answer = (qtype == DNS_TYPE_A);

    uint16_t resp_len = p->len + (has_answer ? 16 : 0);
    struct pbuf *resp = pbuf_alloc(PBUF_TRANSPORT, resp_len, PBUF_RAM);
    if (!resp) {
        pbuf_free(p);
        return;
    }

    memcpy(resp->payload, p->payload, p->len);
    uint8_t *r = (uint8_t *)resp->payload;

    // Set response flags
    r[2] |= 0x80;  // QR = 1 (response)
    r[3] |= 0x80;  // RA = 1 (recursion available, for compatibility)

    if (has_answer) {
        // A query: respond with our IP address
        r[7] = 1;  // ANCOUNT = 1

        uint16_t idx = p->len;
        // DNS Resource Record for A query
        r[idx++] = 0xC0; r[idx++] = 0x0C; // Pointer to name in query
        r[idx++] = 0x00; r[idx++] = 0x01; // Type A
        r[idx++] = 0x00; r[idx++] = 0x01; // Class IN
        r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x00; r[idx++] = 0x3C; // TTL = 60s
        r[idx++] = 0x00; r[idx++] = 0x04; // RDLENGTH = 4
        r[idx++] = 192; r[idx++] = 168; r[idx++] = AP_IP_OCTET; r[idx++] = 1; // IP

        resp->len = resp->tot_len = idx;
    } else {
        // AAAA or other query: respond with empty answer (no error, just no records)
        r[7] = 0;  // ANCOUNT = 0
        resp->len = resp->tot_len = p->len;
    }

    udp_sendto(pcb, resp, addr, port);

    pbuf_free(resp);
    pbuf_free(p);
}

static bool dns_start(void) {
    dns_pcb = udp_new();
    if (!dns_pcb) {
        printf("AP: Failed to create DNS UDP PCB\n");
        return false;
    }

    err_t err = udp_bind(dns_pcb, IP_ADDR_ANY, 53);
    if (err != ERR_OK) {
        printf("AP: Failed to bind DNS port 53 (err=%d)\n", err);
        udp_remove(dns_pcb);
        dns_pcb = NULL;
        return false;
    }

    udp_recv(dns_pcb, dns_recv, NULL);
    printf("AP: DNS server started on port 53\n");
    return true;
}

/* ---------------- URL / Query ---------------- */

// Convert hex character to value, returns -1 if invalid
static int hex_digit_value(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return -1;
}

static void url_decode_n(char *dst, size_t dst_len, const char *src) {
    size_t i = 0;
    while (*src && i + 1 < dst_len) {
        if (*src == '%' && src[1] && src[2]) {
            int hi = hex_digit_value(src[1]);
            int lo = hex_digit_value(src[2]);
            if (hi >= 0 && lo >= 0) {
                // Valid hex escape
                dst[i++] = (hi << 4) | lo;
                src += 3;
            } else {
                // Invalid hex, copy '%' literally
                dst[i++] = *src++;
            }
        } else if (*src == '+') {
            dst[i++] = ' ';
            src++;
        } else {
            dst[i++] = *src++;
        }
    }
    dst[i] = 0;
}

static bool parse_query(const char *q) {
    const char *s = strstr(q, "s=");
    const char *p = strstr(q, "p=");
    if (!s || !p) {
        printf("AP: Missing s= or p= in query\n");
        return false;
    }

    char tmp[128];

    // Parse SSID
    s += 2;
    size_t sl = strcspn(s, "& ");
    if (sl >= sizeof(tmp)) sl = sizeof(tmp) - 1;  // Prevent buffer overflow
    memcpy(tmp, s, sl);
    tmp[sl] = 0;
    url_decode_n(pending_ssid, sizeof(pending_ssid), tmp);

    // Parse password
    p += 2;
    size_t pl = strcspn(p, "& ");
    if (pl >= sizeof(tmp)) pl = sizeof(tmp) - 1;  // Prevent buffer overflow
    memcpy(tmp, p, pl);
    tmp[pl] = 0;
    url_decode_n(pending_pass, sizeof(pending_pass), tmp);

    // Validate SSID (required, 1-32 chars)
    size_t ssid_len = strlen(pending_ssid);
    if (ssid_len == 0) {
        printf("AP: SSID cannot be empty\n");
        return false;
    }
    if (ssid_len > 32) {
        printf("AP: SSID too long (%zu > 32)\n", ssid_len);
        pending_ssid[32] = 0;  // Truncate
    }

    // Validate password (0 for open, or 8-63 for WPA)
    size_t pass_len = strlen(pending_pass);
    if (pass_len > 0 && pass_len < 8) {
        printf("AP: Password too short (%zu < 8)\n", pass_len);
        return false;
    }
    if (pass_len > 63) {
        printf("AP: Password too long (%zu > 63)\n", pass_len);
        pending_pass[63] = 0;  // Truncate
    }

    printf("AP: Parsed credentials - SSID: '%s' (%zu chars), Pass: %zu chars\n",
           pending_ssid, ssid_len, pass_len);

    return true;
}

/* ---------------- HTTP / TCP ---------------- */

// Detect captive portal probe requests from various OS/browsers
static bool is_captive_probe(const char *req) {
    // Android/Chrome
    if (strstr(req, "generate_204")) return true;
    if (strstr(req, "connectivitycheck")) return true;

    // iOS/macOS
    if (strstr(req, "hotspot-detect")) return true;
    if (strstr(req, "captive.apple.com")) return true;

    // Windows
    if (strstr(req, "msftconnecttest")) return true;
    if (strstr(req, "msftncsi")) return true;
    if (strstr(req, "connecttest.txt")) return true;
    if (strstr(req, "ncsi.txt")) return true;

    // Firefox
    if (strstr(req, "detectportal")) return true;
    if (strstr(req, "success.txt")) return true;

    // Samsung
    if (strstr(req, "samsung")) return true;

    return false;
}

// Check if this is a favicon request (avoid wasting bandwidth)
static bool is_favicon_request(const char *req) {
    return strstr(req, "favicon.ico") != NULL;
}

// Forward declarations for HTTP callbacks
static err_t http_sent_cb(void *arg, struct tcp_pcb *pcb, u16_t len);

// Send a minimal 204 No Content response (for favicon, etc.)
static bool send_http_204(struct tcp_pcb *pcb) {
    const char *response =
        "HTTP/1.1 204 No Content\r\n"
        "Connection: close\r\n\r\n";
    size_t len = strlen(response);

    err_t err = tcp_write(pcb, response, len, TCP_WRITE_FLAG_COPY);
    if (err != ERR_OK) {
        tcp_abort(pcb);
        return false;
    }
    tcp_output(pcb);
    tcp_sent(pcb, http_sent_cb);
    return true;
}

static err_t http_sent_cb(void *arg, struct tcp_pcb *pcb, u16_t len) {
    tcp_close(pcb);
    return ERR_OK;
}

static void http_err_cb(void *arg, err_t err) {
    // Connection error occurred (timeout, reset, etc.)
    // The PCB is already freed by lwIP when this is called
    printf("AP: TCP connection error (err=%d)\n", err);
}

// Returns true if response was sent successfully, false if connection was aborted
static bool send_http_response(struct tcp_pcb *pcb, const char *body, const char *status, const char *location) {
    char buf[1024];
    size_t len = body ? strlen(body) : 0;
    int written = 0;

    if (location) {
        // Redirect response
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.1 %s\r\n"
            "Location: %s\r\n"
            "Cache-Control: no-cache, no-store, must-revalidate\r\n"
            "Connection: close\r\n"
            "Content-Length: 0\r\n\r\n",
            status, location);
    } else {
        // Content response with proper headers for modern browsers
        written = snprintf(buf, sizeof(buf),
            "HTTP/1.1 %s\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "Content-Length: %u\r\n"
            "Cache-Control: no-cache, no-store, must-revalidate\r\n"
            "Connection: close\r\n\r\n"
            "%s",
            status, (unsigned)len, body ? body : "");
    }

    if (written > 0 && written < (int)sizeof(buf)) {
        err_t err = tcp_write(pcb, buf, written, TCP_WRITE_FLAG_COPY);
        if (err != ERR_OK) {
            printf("AP: tcp_write failed (err=%d)\n", err);
            tcp_abort(pcb);
            return false;
        }

        err = tcp_output(pcb);
        if (err != ERR_OK) {
            printf("AP: tcp_output failed (err=%d)\n", err);
        }
    } else {
        printf("AP: Response too large or snprintf failed (written=%d)\n", written);
        tcp_abort(pcb);
        return false;
    }

    tcp_sent(pcb, http_sent_cb);
    return true;
}

static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) {
    // Check for errors or connection close
    if (err != ERR_OK) {
        printf("AP: http_recv called with error (err=%d)\n", err);
        if (p) pbuf_free(p);
        return err;
    }

    if (!p) {
        // Client closed connection
        tcp_close(pcb);
        return ERR_OK;
    }

    tcp_recved(pcb, p->tot_len);

    char buf[1024];
    u16_t len = p->tot_len > sizeof(buf) - 1 ? sizeof(buf) - 1 : p->tot_len;
    pbuf_copy_partial(p, buf, len, 0);
    buf[len] = 0;

    char *line = strstr(buf, "\r\n");
    if (line) *line = 0;

    printf("AP: HTTP request: %.60s%s\n", buf, strlen(buf) > 60 ? "..." : "");

    bool success;
    if (strncmp(buf, "GET /save?", 10) == 0) {
        // Form submission - validate and save synchronously to avoid race condition
        if (parse_query(buf + 10)) {
            // Save immediately so we know the result before responding
            if (save_wifi_config(pending_ssid, pending_pass)) {
                // Save succeeded - redirect to done page
                reboot_required = true;
                success = send_http_response(pcb, NULL, "302 Found", "/done");
            } else {
                // Save failed - show error immediately
                success = send_http_response(pcb, html_error_save, "500 Internal Server Error", NULL);
            }
        } else {
            // Validation failed - show error page
            success = send_http_response(pcb, html_error_validation, "400 Bad Request", NULL);
        }
    } else if (strncmp(buf, "GET /done", 9) == 0) {
        // Confirmation page - only reached after successful save
        success = send_http_response(pcb, html_done, "200 OK", NULL);
    } else if (is_favicon_request(buf)) {
        // Favicon - return 204 No Content to save bandwidth
        success = send_http_204(pcb);
    } else if (is_captive_probe(buf)) {
        // Captive portal probe - redirect to trigger portal popup
        // Using 302 redirect is more reliable than serving content directly
        char redirect_url[32];
        snprintf(redirect_url, sizeof(redirect_url), "http://192.168.%d.1/", AP_IP_OCTET);
        success = send_http_response(pcb, NULL, "302 Found", redirect_url);
    } else if (strncmp(buf, "GET / ", 6) == 0 || strncmp(buf, "GET /index", 10) == 0) {
        // Main page request
        success = send_http_response(pcb, html_form, "200 OK", NULL);
    } else {
        // Any other request - serve the form (catch-all for captive portal)
        success = send_http_response(pcb, html_form, "200 OK", NULL);
    }

    pbuf_free(p);

    // If send_http_response aborted the connection, we must return ERR_ABRT
    // to tell lwIP the PCB is no longer valid
    return success ? ERR_OK : ERR_ABRT;
}

static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err) {
    if (err != ERR_OK || pcb == NULL) {
        printf("AP: http_accept error (err=%d, pcb=%p)\n", err, pcb);
        return ERR_VAL;
    }

    printf("AP: New HTTP connection from %s\n", ip4addr_ntoa(&pcb->remote_ip));

    // Set up callbacks for this connection
    tcp_recv(pcb, http_recv);
    tcp_err(pcb, http_err_cb);

    return ERR_OK;
}

/* ---------------- MAIN AP MODE ---------------- */

void run_ap_setup_mode(void) {
    uint8_t mac[6];
    char ssid[32];

    if (cyw43_wifi_get_mac(&cyw43_state, CYW43_ITF_AP, mac) == 0) {
        snprintf(ssid, sizeof(ssid), "StageKit-%02X%02X%02X",
                 mac[3], mac[4], mac[5]);
    } else {
        strcpy(ssid, "StageKit-Setup");
    }
    
    printf("AP: Starting Access Point '%s'...\n", ssid);

    cyw43_arch_enable_ap_mode(ssid, AP_PASSWORD, CYW43_AUTH_WPA2_AES_PSK);

    // CRITICAL: Give the CYW43 time to fully initialize the AP
    // Without this delay, TCP connections may fail even though WiFi associates
    printf("AP: Waiting for AP to initialize...\n");
    for (int i = 0; i < 20; i++) {
        watchdog_update();
        sleep_ms(100);
    }

    // Verify AP interface is up
    struct netif *n = &cyw43_state.netif[CYW43_ITF_AP];
    if (!netif_is_link_up(n)) {
        printf("AP: WARNING - AP interface link is DOWN!\n");
        printf("AP: WiFi network may not be visible to clients\n");
        // Try waiting a bit longer
        for (int i = 0; i < 30; i++) {
            watchdog_update();
            sleep_ms(100);
            if (netif_is_link_up(n)) {
                printf("AP: Link came up after additional delay\n");
                break;
            }
        }
    }

    if (netif_is_link_up(n)) {
        printf("AP: AP interface is UP and ready\n");
    } else {
        printf("AP: ERROR - AP interface still DOWN after 5 seconds!\n");
        printf("AP: Check CYW43 firmware and hardware\n");
    }

    // Disable power save mode to ensure web server responsiveness
    cyw43_wifi_pm(&cyw43_state, cyw43_pm_value(CYW43_NO_POWERSAVE_MODE, 20, 1, 1, 1));

    ip4_addr_t ip, mask, gw;
    IP4_ADDR(&ip, 192, 168, AP_IP_OCTET, 1);
    IP4_ADDR(&mask, 255, 255, 255, 0);
    IP4_ADDR(&gw, 192, 168, AP_IP_OCTET, 1); // AP is its own gateway

    cyw43_arch_lwip_begin();
    
    netif_set_addr(n, &ip, &mask, &gw);
    netif_set_up(n);
    netif_set_default(n);
        
    dhcp_server_init(&dhcp_server, &ip, &mask);

    if (!dns_start()) {
        printf("AP: WARNING - DNS server failed to start, captive portal may not work\n");
    }

    struct tcp_pcb *pcb = tcp_new();
    if (!pcb) {
        printf("AP: Failed to create TCP PCB\n");
        cyw43_arch_lwip_end();
        return;
    }

    err_t err = tcp_bind(pcb, IP_ADDR_ANY, 80);

    if (err != ERR_OK) {
        printf("AP: Failed to bind TCP port 80 (err=%d)\n", err);
        tcp_close(pcb);
    } else {
        struct tcp_pcb *listen_pcb = tcp_listen(pcb);
        if (!listen_pcb) {
            printf("AP: tcp_listen failed\n");
            tcp_close(pcb);
        } else {
            tcp_accept(listen_pcb, http_accept);
            printf("AP: HTTP server listening on port 80\n");
        }
    }
    
    cyw43_arch_lwip_end();

    while (true) {
        // CRITICAL: Poll the network stack to process TCP callbacks
        // Without this, TCP connections may not be handled reliably
        cyw43_arch_poll();

        if (reboot_required) {
            // Allow time for HTTP response to be sent before rebooting
            printf("AP: Rebooting in 1s...\n");
            for (int i = 0; i < 50; i++) {
                cyw43_arch_poll();  // Keep polling during reboot delay
                sleep_ms(20);
            }
            watchdog_enable(100, 1);
            while (1);
        }

        watchdog_update();
        sleep_ms(10);  // Reduced from 200ms for more responsive TCP handling
    }
}



