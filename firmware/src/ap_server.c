#include "ap_server.h"
#include "pico/cyw43_arch.h"
#include "pico/stdlib.h"
#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/err.h"

// Manual definition to prevent "undefined identifier" errors
#ifndef TCP_WRITE_FLAG_COPY
#define TCP_WRITE_FLAG_COPY 0x01
#endif

#include "dhcpserver.h"
#include "config_parser.h"
#include "littlefs_hal.h"
#include "lfs.h"
#include "hardware/watchdog.h"
#include <stdio.h>
#include <string.h>

#define AP_PASSWORD "rockband" // Password to join the Setup WiFi

// Static DHCP server instance
static dhcp_server_t dhcp_server;

// Global flags and buffers for main loop handling
static volatile bool reboot_required = false;
static volatile bool save_pending = false;
static char pending_ssid[64];
static char pending_pass[64];

// HTML Content
const char *html_form = 
    "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n"
    "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width, initial-scale=1'></head>"
    "<body style='font-family:sans-serif; text-align:center; padding:20px;'>"
    "<h1>StageKit Setup</h1>"
    "<form action='/save' method='get'>"
    "<p>WiFi Name (SSID):<br><input type='text' name='s' style='padding:8px;'></p>"
    "<p>Password:<br><input type='text' name='p' style='padding:8px;'></p>"
    "<input type='submit' value='Save & Connect' style='padding:10px 20px; font-size:16px;'>"
    "</form></body></html>";

const char *html_success = 
    "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n"
    "<html><body style='font-family:sans-serif; text-align:center; padding:50px;'>"
    "<h1>Saved!</h1><p>The device is rebooting...</p>"
    "<p>Please reconnect your phone/PC to your normal WiFi.</p></body></html>";

// URL Decoder
void url_decode(char *dst, const char *src) {
    char a, b;
    while (*src) {
        if (*src == '%' && ((a = src[1]) && (b = src[2]))) {
            if (a >= 'a') a -= 'a'-'A'; if (a >= 'A') a -= ('A' - 10); else a -= '0';
            if (b >= 'a') b -= 'a'-'A'; if (b >= 'A') b -= ('A' - 10); else b -= '0';
            *dst++ = 16 * a + b; src += 3;
        } else if (*src == '+') {
            *dst++ = ' '; src++;
        } else {
            *dst++ = *src++;
        }
    }
    *dst = '\0';
}

// Save credentials to LittleFS
// NOTE: This must only be called from the main thread, not an interrupt!
void save_wifi_config(const char *ssid, const char *password) {
    lfs_t *lfs = littlefs_get();
    lfs_file_t file;

    // Open/create settings file
    int err = lfs_file_open(lfs, &file, CONFIG_FILE_PATH, LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC);
    if (err < 0) {
        printf("AP: Failed to open %s for writing (err=%d)\n", CONFIG_FILE_PATH, err);
        return;
    }

    char file_content[256];
    // Format matches config_parser.c expectations
    snprintf(file_content, sizeof(file_content),
        "# Auto-generated by AP Setup\n"
        "CIRCUITPY_WIFI_SSID = \"%s\"\n"
        "CIRCUITPY_WIFI_PASSWORD = \"%s\"\n",
        ssid, password);

    lfs_ssize_t written = lfs_file_write(lfs, &file, file_content, strlen(file_content));
    lfs_file_close(lfs, &file);

    if (written > 0) {
        printf("AP: Config saved to %s (%d bytes)\n", CONFIG_FILE_PATH, (int)written);
    } else {
        printf("AP: Failed to write config (err=%d)\n", (int)written);
    }
}

err_t http_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
    if (!p) { 
        tcp_close(tpcb); 
        return ERR_OK; 
    }

    // 1. Acknowledge that we have received the data
    tcp_recved(tpcb, p->tot_len);

    char *req = (char *)p->payload;

    // FIX: Ensure safety constraints
    if (p->tot_len >= 512) { // Sanity check size
        pbuf_free(p);
        return ERR_VAL;
    }
    
    // FIX: Create a local safe buffer with null termination
    char buf[512];
    u16_t len = (p->tot_len < sizeof(buf) - 1) ? p->tot_len : (sizeof(buf) - 1);
    memcpy(buf, req, len);
    buf[len] = '\0'; // Manually enforce null termination
    
    // Check if this is the Save request: GET /save?s=SSID&p=PASS
    if (strncmp(buf, "GET /save", 9) == 0) {
        
        char *s_ptr = strstr(buf, "s=");
        char *p_ptr = strstr(buf, "p=");
        
        if (s_ptr && p_ptr) {
            char *end;
            
            s_ptr += 2; // Skip "s="
            end = strchr(s_ptr, '&');
            if (end) *end = 0; 
            url_decode(pending_ssid, s_ptr); // Decode to GLOBAL var
            
            p_ptr += 2; // Skip "p="
            end = strchr(p_ptr, ' '); // End of HTTP line
            if (end) *end = 0;
            url_decode(pending_pass, p_ptr); // Decode to GLOBAL var
            
            printf("AP: Credentials received for '%s'\n", pending_ssid);
            
            // CRITICAL: Do NOT write to flash here. Signal main loop.
            save_pending = true; 
            
            // Send success page
            tcp_write(tpcb, html_success, strlen(html_success), TCP_WRITE_FLAG_COPY);
            
            // 2. IMPORTANT: Close connection so browser knows we are done
            tcp_close(tpcb);
        }
    } else {
        // Send the Form
        tcp_write(tpcb, html_form, strlen(html_form), TCP_WRITE_FLAG_COPY);
        
        // 3. IMPORTANT: Close connection here too!
        tcp_close(tpcb);
    }
    
    pbuf_free(p);
    return ERR_OK;
}

err_t connection_callback(void *arg, struct tcp_pcb *newpcb, err_t err) {
    tcp_recv(newpcb, http_callback);
    return ERR_OK;
}

void run_ap_setup_mode(void) {
    printf("\nENTERING AP SETUP MODE\n");
    
    uint8_t mac[6];
    char ssid[32];
    
    // Ensure WiFi chip is on
    if (cyw43_wifi_get_mac(&cyw43_state, CYW43_ITF_AP, mac) == 0) {
        snprintf(ssid, sizeof(ssid), "StageKit-Setup-%02X%02X%02X", mac[3], mac[4], mac[5]);
    } else {
        sprintf(ssid, "StageKit-Setup-Default");
    }
    
    // Start AP
    cyw43_arch_enable_ap_mode(ssid, AP_PASSWORD, CYW43_AUTH_WPA2_AES_PSK);
    printf("AP Started: '%s' (Pass: %s)\n", ssid, AP_PASSWORD);

    sleep_ms(500);

    // Configure gateway and netmask
    ip4_addr_t gw, mask;
    IP4_ADDR(&gw, 192, 168, 4, 1);
    IP4_ADDR(&mask, 255, 255, 255, 0);

    // Start DHCP server
    cyw43_arch_lwip_begin();
    dhcp_server_init(&dhcp_server, &gw, &mask);
    cyw43_arch_lwip_end();
    printf("DHCP server started on 192.168.4.1\n");
    
    // Start Web Server
    cyw43_arch_lwip_begin();
    struct tcp_pcb *pcb = tcp_new();
    tcp_bind(pcb, IP_ADDR_ANY, 80);
    pcb = tcp_listen(pcb);
    tcp_accept(pcb, connection_callback);
    cyw43_arch_lwip_end();

    printf("Web server listening on port 80. Waiting for user...\n");
    printf("Connect to WiFi '%s' and open http://192.168.4.1\n", ssid);
    
    while(true) {
        // 1. Handle Flash Save (Safe context)
        if (save_pending) {
            printf("AP: Main loop saving config...\n");
            save_wifi_config(pending_ssid, pending_pass);
            save_pending = false;
            reboot_required = true;
        }

        // 2. Handle Reboot (Safe context)
        if (reboot_required) {
            printf("Rebooting in 2 seconds...\n");
            watchdog_enable(2000, 1); 
            while(1); // Infinite loop to force watchdog reset
        }
        
        // 3. UI Blinking
        for(int i=0; i<3; i++) {
            cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 1);
            sleep_ms(100);
            cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 0);
            sleep_ms(100);
        }
        sleep_ms(500);
        watchdog_update();
    }
}
