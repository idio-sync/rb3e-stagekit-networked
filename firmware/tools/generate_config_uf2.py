#!/usr/bin/env python3
"""
Generate a UF2 file containing WiFi credentials for RB3E StageKit firmware.

This script creates a LittleFS filesystem image with a settings.toml file
containing your WiFi credentials, then converts it to UF2 format for flashing.

Usage:
    python generate_config_uf2.py --ssid "YourNetwork" --password "YourPassword"
    python generate_config_uf2.py --ssid "YourNetwork" --password "YourPassword" --board pico2_w

The generated UF2 file can be dragged onto the Pico's USB drive after the main
firmware has been flashed.
"""

import argparse
import struct
import sys
from pathlib import Path

# LittleFS configuration (must match firmware)
LFS_BLOCK_SIZE = 4096
LFS_BLOCK_COUNT = 64  # 256KB / 4KB
LFS_FLASH_SIZE = LFS_BLOCK_SIZE * LFS_BLOCK_COUNT  # 256KB

# Flash layout
PICO_FLASH_SIZE = 2 * 1024 * 1024  # 2MB
LFS_FLASH_OFFSET = PICO_FLASH_SIZE - LFS_FLASH_SIZE  # 0x1C0000

# UF2 constants
UF2_MAGIC_START0 = 0x0A324655  # "UF2\n"
UF2_MAGIC_START1 = 0x9E5D5157
UF2_MAGIC_END = 0x0AB16F30
UF2_FLAG_FAMILY_ID = 0x00002000

# UF2 family IDs
UF2_FAMILY_RP2040 = 0xE48BFF56
UF2_FAMILY_RP2350_ARM = 0xE48BFF59
UF2_FAMILY_RP2350_RISCV = 0xE48BFF5A

# Board configurations
BOARD_CONFIG = {
    'pico_w': {
        'family_id': UF2_FAMILY_RP2040,
        'flash_base': 0x10000000,
    },
    'pico2_w': {
        'family_id': UF2_FAMILY_RP2350_ARM,
        'flash_base': 0x10000000,
    },
}


def create_settings_toml(ssid: str, password: str) -> bytes:
    """Create the settings.toml file content."""
    content = f'''# RB3E StageKit Bridge Configuration
# Generated by generate_config_uf2.py

CIRCUITPY_WIFI_SSID = "{ssid}"
CIRCUITPY_WIFI_PASSWORD = "{password}"
'''
    return content.encode('utf-8')


def create_littlefs_image(settings_content: bytes) -> bytes:
    """
    Create a minimal LittleFS image with the settings.toml file.

    This creates a valid LittleFS v2 image with the settings.toml file.
    Configuration MUST match firmware/src/littlefs_hal.c exactly!
    """
    try:
        from littlefs import LittleFS

        # Create LittleFS with configuration matching firmware exactly
        # See firmware/src/littlefs_hal.c for the firmware's lfs_config
        fs = LittleFS(
            block_size=LFS_BLOCK_SIZE,       # 4096
            block_count=LFS_BLOCK_COUNT,     # 64
            prog_size=256,                   # FLASH_PAGE_SIZE
            read_size=1,
            cache_size=LFS_BLOCK_SIZE,       # Must match firmware (4096)
            lookahead_size=16,               # Must match firmware
            block_cycles=500,                # Must match firmware
        )

        # Format and mount
        fs.format()
        fs.mount()

        # Write settings file
        with fs.open('/settings.toml', 'w') as f:
            f.write(settings_content.decode('utf-8'))

        # Get the image
        fs.unmount()
        return bytes(fs.context.buffer)

    except ImportError:
        print("Error: littlefs-python package not installed.", file=sys.stderr)
        print("Install with: pip install littlefs-python", file=sys.stderr)
        sys.exit(1)


def create_uf2(data: bytes, base_address: int, family_id: int) -> bytes:
    """Convert binary data to UF2 format."""
    uf2_blocks = []
    data_len = len(data)
    num_blocks = (data_len + 255) // 256  # 256 bytes per UF2 block

    for block_no in range(num_blocks):
        offset = block_no * 256
        chunk = data[offset:offset + 256]

        # Pad chunk to 256 bytes if needed
        if len(chunk) < 256:
            chunk = chunk + b'\x00' * (256 - len(chunk))

        # Build UF2 block (512 bytes total)
        block = struct.pack(
            '<IIIIIIII',
            UF2_MAGIC_START0,
            UF2_MAGIC_START1,
            UF2_FLAG_FAMILY_ID,
            base_address + offset,
            256,  # payload size
            block_no,
            num_blocks,
            family_id,
        )
        block += chunk
        block += b'\x00' * (512 - 32 - 256 - 4)  # padding
        block += struct.pack('<I', UF2_MAGIC_END)

        uf2_blocks.append(block)

    return b''.join(uf2_blocks)


def main():
    parser = argparse.ArgumentParser(
        description='Generate WiFi credentials UF2 for RB3E StageKit firmware',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s --ssid "MyNetwork" --password "MyPassword"
  %(prog)s --ssid "MyNetwork" --password "MyPassword" --output my_config.uf2
  %(prog)s --ssid "MyNetwork" --password "MyPassword" --board pico2_w

The generated UF2 should be flashed AFTER the main firmware UF2.
''')

    parser.add_argument('--ssid', '-s', required=True,
                        help='WiFi network name (SSID)')
    parser.add_argument('--password', '-p', required=True,
                        help='WiFi password')
    parser.add_argument('--output', '-o', default='wifi_config.uf2',
                        help='Output UF2 filename (default: wifi_config.uf2)')
    parser.add_argument('--board', '-b', choices=['pico_w', 'pico2_w'],
                        default='pico_w',
                        help='Target board (default: pico_w)')

    args = parser.parse_args()

    # Validate inputs
    if len(args.ssid) > 32:
        print("Error: SSID must be 32 characters or less", file=sys.stderr)
        sys.exit(1)
    if len(args.password) > 64:
        print("Error: Password must be 64 characters or less", file=sys.stderr)
        sys.exit(1)

    print(f"Creating WiFi config for SSID: {args.ssid}")
    print(f"Target board: {args.board}")

    # Create settings.toml content
    settings = create_settings_toml(args.ssid, args.password)

    # Create LittleFS image
    print("Creating LittleFS image...")
    lfs_image = create_littlefs_image(settings)

    # Get board configuration
    board_cfg = BOARD_CONFIG[args.board]
    flash_base = board_cfg['flash_base']
    family_id = board_cfg['family_id']

    # Calculate flash address for LittleFS region
    lfs_address = flash_base + LFS_FLASH_OFFSET

    print(f"LittleFS flash offset: 0x{LFS_FLASH_OFFSET:X}")
    print(f"UF2 target address: 0x{lfs_address:X}")

    # Convert to UF2
    print("Converting to UF2 format...")
    uf2_data = create_uf2(lfs_image, lfs_address, family_id)

    # Write output file
    output_path = Path(args.output)
    output_path.write_bytes(uf2_data)

    print(f"Generated: {output_path} ({len(uf2_data)} bytes)")
    print()
    print("To use:")
    print("  1. Flash the main firmware UF2 first (rb3e_stagekit_*.uf2)")
    print("  2. Then flash this config UF2 (drag to RPI-RP2 drive)")


if __name__ == '__main__':
    main()
